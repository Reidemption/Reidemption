#Theory

#create a new count for each function
#if X > Y == C.compares
#X,Y = Y,X == C.swaps
# increment C.swaps whenever values change
# increment C.comapres whenever values are compared to each other
# 

'''
Big O
(Polynomial Algorithms/ Tractable(somethine we can handle))
1 - same number of steps no matter the size of N
logN - binary search
NlogN - 
N^2 - 
N^3 - 
N^x -
---
---
(Exponential Algorithms/ intractable(somethine too large to deal with))
2^N - SAT, Towers of Hanoi
10^(N/2) -
N! - Traveling Salesman
'''

'''
P(Polynomial) < NP(Nondeterministic Polynomial) < Exponential < Unsolvable

Exponential
- Towers of Hanoi


NP - no algorithm to find the answer, but if we HAD the answer we could verify it in polynomial form
- SAT
- Factoring
- Traveling Salesman

Possible that all NP problems can sink into P
Solve SAT -> Solve everything else
'''

#Halting problem - write an algorithm. Input is some general code and input to that code
#reponds yes or no if the code will halt